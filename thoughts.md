My thoughts on these 5 programming languages: C, ARM, Smalltalk, Clojure, Swift

---

In this paper I would like to talk about my experiences with 5 programming languages that we have learnt so far in the class.

The first language that we talked about was C. Since writing a "Hello World" program was simple, I had an immediate impression that C was very simple and minimal. I then took that program and expanded its functionality so that it could ask for an user's name from stdin and print out the greeting. Finding the built-in function from the core library to read user's input was simple enough, though providing needed parameters was not so clear. Apparently, scanf had a lot of format specifiers to choose from and configure. This made me realize that, even though C was minimal, it was super powerful and flexible. After finishing reading from the input, I needed to figure out a way to store that into a variable and print it out to the terminal. There was no string data type type that I could find. That said, the way was to initialize a char type variable with fix-length and use that to store the input since string was made of char anyway. The next program that I wrote was to ask user to input two integers and then a sum would be printed out. Since I already knew how to use scanf to read user's input, it was straightforward to use it again to ask for integer though this time, I needed to store them in a integer variable. Calculating the sum and printing it out was easy enough. Then I moved on to calculate the sum of 3 integers, the average, maximum and minimum. This time I learnt about array and function. I made 4 functions to calculate the sum, average, max and min of 3 integers where they take in an array of size 3 as their parameters. An interesting about functions in C was that they were all needed to be defined in the beginning of files or in separate header files. I liked it a lot since it provided more readability for developers themselves as well as reviewers. Moving on to calculating the median and mode was more challenging. To calculate the mean, I had to implement a sorting algorithm to sort the array first then pick the middle value. I chose to implement selection sort since it was pretty easy to understand and implement. Though it took sometimes, I was able to do it. To calculate the mode, I planned to use a hashmap to store the key-value pairs of characters and their number of occurrences. However, that was not the case since there was no built-in hashmap data structure in C's core library. That said, I had two options to either implement my own hashmap then use it or look for other solution. I then found a solution that implement counting sort that was a good fit, implemented it and had it worked. I then learnt to appreciate hashmap more after spending a lot of time solving that one. Overall, I thought that C was a good language. It was simple yet powerful. Even though it did not support a lot of handy core library as Go and Python, it was pretty easy to use and understand. Once C was used carefully, it would suppose to be super fast and efficient.

The second language that we learnt was ARM. There was no way to implement a "Hello World" program so I moved on to playing with addition problem. The commands in ARM were pretty limited as they were all low-level system calls. There were also a handful of registers that I could use to store my data on. In order to add two integers, I had to first declare these values as words in memory, move/store addresses in registers, load values from these addresses, add them together and store them back again in registers. Unlike C, Go or Python, in order to add two numbers, I couldn't simply use a "+" symbol and have them added together. I had to followed a set of instructions to grab these values at their addresses and add them manually using a primitive ADD method. I was really fascinated by this and also grateful for the fact that C and other modern programming languages abstracted all of these behind-the-scene addition for us. I then tried to implement multiplication for 2 numbers by adding one a number of times. I learnt to use branching to implement a loop with a counter so I could repeatedly add a number of times. After I had it worked, I took on a challenge to use bit manipulation to implement multiplication instead. That was then I learnt about bitwise AND and bit shifting. It took me more than 4 hours to implement everything together to make it run. It was a long journey but I did learn a lot from it. Later on, I tried to implement bubble sort using a stack pointer, though I was able to only had it worked partly. Again, I enjoyed the progress a lot as it helped me understand the low-level instruction of a program. I thought that using ARM was a good way to learn about computer system, but not so fun to quickly prototype things.

The third language was Smalltalk. Having some experiences with objected orient programming before, I thought it was an easy transition for me to learn Smalltalk. It was actually. However, the only that I spent most of my time on was actually to make Squeak do what I told it to do. I tried to write a program to calculate the areas and volumes of different 2D and 3D shapes. The idea was to define classes for abstract shapes such as 2D and 3D ones then have a hierarchy for actual shapes. I was able to complete the program in the end, and also have tests for them. Though it took a lot of time tinkering with Squeak's UI, this was an opportunity for me to relearn about objects, messages and inheritance.

The fourth language that we learnt was Clojure. Even though I had some trouble understanding the concept of functional programming in the beginning, I found Clojure to be my favourite language so far as I spent a lot of time with it. At first, I tried to write a program to calculate the factorial of a given number. I came to know about how to start and end a loop, how to write if-else statement, and how to write a recursive function. It was super cool to see all of that worked and how different they were compared to other languages that I had seen. I also tried to figure out a way to write tests for them that looked really clean and neat. Since I really enjoyed that process, I spent more time looking into it and trying to solve different problems so that I could be more familiar with it. The next one was to calculate the sum of numbers up to n. This was very similar to how I implemented the last one since I also used the loop and recursive approach to iterate through and calculate a final sum/product. Another one was to reverse a sequence. If I were to do it in other language, I would have to iterate through the sequence backward and add them all together in that reverse order. With Clojure, I found out that I could use conj to conjoining an element to at list at the beginning and reduce to apply that conj function to every element in the sequence so that I could have a reversed list in the end. I went ahead to implement it, wrote tests and they worked as I thought. The interesting was that, it only took 1-2 line of code with using 2 core functions. I also tried to write a program that check if a string was a palindrome and was impressed by how simple and clean Clojure's approach was. Since a palindrome was defined as a word or sequence that read the same backward as forward, I could just use a reverse function to get the given string in reverse and compare these two. Again, it only took 1-2 line of code and looked really clean. So far so good, I did some other problems to explore some other core library's functions and ended up wanting to build a more complicated program. I chose Tic Tac Toe. It turned out to be not so difficult except the fact that everything was immutable. One trick that helped me accomplish that was to always rewrite the function definition for the board whenever a player made a move. Since I made the board as a hashmap, it was simple and straightforward after then. Another problem that I had was to terminate the program when one player won. Apparently, in order to do so, I had to rearrange the code in a different order so the loop and recursive function knew when to stop. It was only a small detail but still took me quite sometimes to figure out. Overall, I enjoyed working with Clojure a lot since it helped me think and approach a problem in a more creative way.

The last language was Swift. Swift shared some C-like syntax and was really powerful too. My first impression with Swift, compared to C, was that Swift was way more complicated. It supported everything that C had and more. There were some pretty interesting concepts that one could not find in C such as: optional, let and var differences, enum and class differences and so on. As soon as I started solving problems, I realized how often these concepts occurred. It seemed like they were almost everywhere in the language themselves. I thought that the way Swift required us to explicitly specify data types whenever we used anything was a really good practice. I also thought that optional type was a really cool and practical idea for many real-word use cases, even though it introduced another level of complexity where one had to wrap/unwrap them. Another powerful feature of Swift was protocol. It had a lot of similarities with Go's interface, which both encouraged design by composition. I thought that was really powerful and useful. Overall, I enjoyed Swift a lot because it was very opinionated. It had many modern features that was suitable for the current programming paradigm.

At the end of the day, I have learnt a lot of new concepts with these 5 programming languages. They all have different strengths and weaknesses depending on the problems that we're trying to solve.
